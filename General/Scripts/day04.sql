CREATE TABLE TBL_USER(
	NAME VARCHAR2(1000),
	AGE NUMBER
);

-- 테이블명 수정
ALTER TABLE TBL_USER RENAME TO TBL_USERS;

-- 칼럼 추가
ALTER TABLE TBL_USERS ADD(
	GENDER CHAR(1)
);
	
-- 칼럼명 수정 
ALTER TABLE TBL_USERS RENAME COLUMN NAME TO NICKNAME;

-- 칼럼 삭제
ALTER TABLE TBL_USERS DROP COLUMN GENDER;

-- 칼럼 타입 수정
ALTER TABLE TBL_USERS MODIFY (AGE VARCHAR2(20));

INSERT INTO TBL_USERS (NICKNAME, AGE)
VALUES('TEST', '22살');

TRUNCATE TABLE TBL_USERS; -- 사용시 주의!!

DELETE FROM TBL_USERS;
----------------------------------------------------------

-- 테이블 삭제
DROP TABLE TBL_USERS; 

/*
 * [실습]
 * 자동차 테이블 생성 -- CREATE
 * - 자동차 번호
 * - 브랜드
 * - 출시 날짜
 * - 색상
 * - 가격
 */ 

CREATE TABLE TBL_CAR(
	CAR_NUMBER NUMBER,
	CAR_BRAND VARCHAR2(100),
	CAR_DATE VARCHAR2(100),
	CAR_COLOR VARCHAR2(50),
	CAR_PRICE NUMBER
);

ALTER TABLE TBL_CAR MODIFY(CAR_NUMBER VARCHAR2(1000));
ALTER TABLE TBL_CAR MODIFY(CAR_DATE DATE);

-- 제약 조건 추가하기
ALTER TABLE TBL_CAR 
	ADD CONSTRAINT PK_CAR PRIMARY KEY(CAR_NUMBER); 
-- ADD CONSTRAINT : 제약 조건 추가
-- PK_CAR : 제약조건의 이름을 설정 PK_테이블명
-- PRIMARY KEY(CAR_NUMBER) : PK라는 제약조건을 (CAR_NUMBER) 칼럼에 추가한다.

-- 제약 조건 삭제
ALTER TABLE TBL_CAR DROP CONSTRAINT PK_CAR;

DROP TABLE TBL_CAR;

-- 테이블 생성시 제약조건을 추가할 수 있다.
CREATE TABLE TBL_CAR(
	CAR_NUMBER VARCHAR2(1000) CONSTRAINT PK_CAR PRIMARY KEY,
	CAR_BRAND VARCHAR2(1000),
	CAR_DATE DATE,
	CAR_COLOR VARCHAR2(1000),
	CAR_PRICE NUMBER
);

CREATE TABLE TBL_CAR(
	CAR_NUMBER VARCHAR2(1000),
	CAR_BRAND VARCHAR2(1000),
	CAR_DATE DATE,
	CAR_COLOR VARCHAR2(1000),
	CAR_PRICE NUMBER,
	CONSTRAINT PK_CAR PRIMARY KEY(CAR_NUMBER)
);


SELECT * FROM TBL_CAR tc ;

/*
 * [실습]
 * 상품(PRODUCT) 테이블 생성
 * 제약조건 PK를 설정한다.
 * - 상품번호
 * - 상품이름
 * - 가격
 */

CREATE TABLE TBL_PRODUCT(
	PD_NUMBER VARCHAR2(1000),
	PD_NAME VARCHAR2(1000),
	PRICE NUMBER,
	CONSTRAINT PK_PRODUCT PRIMARY KEY(PD_NUMBER)
);

ALTER TABLE TBL_PRODUCT MODIFY(PD_NUMBER NUMBER);

INSERT INTO TBL_PRODUCT(PD_NUMBER, PD_NAME, PRICE)
VALUES(1 , '아이폰', 1000000)

-- 오류! 상품번호가 PK라서 중복 허용 X
--INSERT INTO TBL_PRODUCT(PD_NUMBER, PD_NAME, PRICE)
--VALUES(1 , '갤럭시 워치', 1000000)

-- 오류! 상품번호가 PK라서 NULL을 허용 X
--INSERT INTO TBL_PRODUCT(PD_NUMBER, PD_NAME, PRICE)
--VALUES(NULL , '삼성노트북', 2000000)

INSERT INTO TBL_PRODUCT(PD_NUMBER, PD_NAME, PRICE)
VALUES(2 , '갤럭시 Z 플맆', 1200000)

INSERT INTO TBL_PRODUCT(PD_NUMBER, PD_NAME, PRICE)
VALUES(3 , '삼성노트북', 2000000)

DELETE FROM TBL_PRODUCT
WHERE PD_NUMBER = 4

SELECT * FROM TBL_PRODUCT tp ;

-- PK는 고유한 칼럼에 많이 사용된다. EX) 아이디, 번호
SELECT * FROM TBL_PRODUCT tp
WHERE PD_NUMBER = 3;

----------------------------------------------------------
 
-- FK(FOREIGN KEY)
-- 학교테이블 , 학생테이블

CREATE TABLE TBL_SCHOOL(
	SCHOOL_ID NUMBER,
	NAME VARCHAR2(1000),
	CONSTRAINT PK_SCHOOL PRIMARY KEY(SCHOOL_ID)
);

CREATE TABLE TBL_STUDENT2(
	STUDENT_ID NUMBER,
	NAME VARCHAR2(1000),
	AGE NUMBER,
	SCHOOL_ID NUMBER, 
	CONSTRAINT PK_STUDENT PRIMARY KEY(STUDENT_ID),
	CONSTRAINT FK_STUDENT FOREIGN KEY(SCHOOL_ID) 
		REFERENCES TBL_SCHOOL(SCHOOL_ID) 
);

INSERT INTO TBL_SCHOOL
VALUES(1, 'JAVA 고등학교');

INSERT INTO TBL_SCHOOL
VALUES(2, 'DBMS 고등학교');

INSERT INTO TBL_SCHOOL
VALUES(3, 'PYTHON 고등학교');

-- 오류 발생! FK인 SCHOOL_ID에 존재하지 않는 값을 저장하려고 함
INSERT INTO TBL_STUDENT2 (STUDENT_ID, NAME, AGE, SCHOOL_ID)
VALUES(5, '김철수', 17, 100);

-- STUDENT2 에 학생추가
INSERT INTO TBL_STUDENT2 (STUDENT_ID, NAME, AGE, SCHOOL_ID)
VALUES(1, '김철수', 17, 1);

INSERT INTO TBL_STUDENT2 (STUDENT_ID, NAME, AGE, SCHOOL_ID)
VALUES(2, '박웅이', 17, 1);

INSERT INTO TBL_STUDENT2 (STUDENT_ID, NAME, AGE, SCHOOL_ID)
VALUES(3, '신짱구', 18, 2);

INSERT INTO TBL_STUDENT2 (STUDENT_ID, NAME, AGE, SCHOOL_ID)
VALUES(4, '신유리', 18, 2);

SELECT * FROM TBL_SCHOOL ts 
ORDER BY SCHOOL_ID;

SELECT * FROM TBL_STUDENT2 ts 

------------------------------------------------------------------

DROP TABLE TBL_MEMBER ;

CREATE TABLE TBL_MEMBER(
	MEMBER_ID NUMBER,
	NAME VARCHAR2(1000) NOT NULL,
	EMAIL VARCHAR2(1000),
	GENDER CHAR(1) DEFAULT 'N',
	CONSTRAINT PK_MEMBER PRIMARY KEY(MEMBER_ID),
	CONSTRAINT UK_MEMBER UNIQUE(EMAIL),
	CONSTRAINT CK_MEMBER CHECK(GENDER IN ('M', 'F', 'N'))
);

INSERT INTO TBL_MEMBER(MEMBER_ID, NAME, EMAIL)
VALUES(1, 'TEST', 'TEST@naver.com')

-- 오류 발생! CHECK 제약조건에 위배됨!
INSERT INTO TBL_MEMBER(MEMBER_ID, NAME, EMAIL, GENDER)
VALUES(2, 'TEST2', 'TEST2@naver.com', 'A');

INSERT INTO TBL_MEMBER(MEMBER_ID, NAME, EMAIL, GENDER)
VALUES(2, 'TEST2', 'TEST2@naver.com', 'F');

INSERT INTO TBL_MEMBER(MEMBER_ID, NAME, EMAIL, GENDER)
VALUES(3, 'TEST3', 'TEST3@naver.com', 'M');

SELECT * FROM TBL_MEMBER tm ;


-------------------------------------------------------------------

-- 복합키 설정
CREATE TABLE TBL_FLOWER(
	NAME VARCHAR2(1000),
	COLOR VARCHAR2(1000),
	PRICE NUMBER,
	CONSTRAINT PK_FLOWER PRIMARY KEY(NAME, COLOR)
);

INSERT INTO TBL_FLOWER(NAME, COLOR, PRICE)
VALUES('해바라기', '노랑', 5000);

-- 오류 발생! 복합키로 설정한 2개의 칼럼이 모두 일치하면 중복처리된다. 그래서 INSERT불가
INSERT INTO TBL_FLOWER(NAME, COLOR, PRICE)
VALUES('해바라기', '노랑', 6000); -- 위에 '해바라기', '노랑' 이 중복됨 

INSERT INTO TBL_FLOWER(NAME, COLOR, PRICE)
VALUES('해바라기', '빨강', 6000);

INSERT INTO TBL_FLOWER(NAME, COLOR, PRICE)
VALUES('장미', '빨강', 7000);

SELECT * FROM TBL_FLOWER tf ;

/*
 *  
 */

DROP TABLE TBL_MEMBER;

-- 회원
CREATE TABLE TBL_MEMBER(
	MEMBER_ID NUMBER,
	LOGIN_ID VARCHAR2(1000),
	PASSWORD VARCHAR2(1000),
	CONSTRAINT PK_MEMBER PRIMARY KEY (MEMBER_ID) 
);

-- 게시판
CREATE TABLE TBL_BOARD(
	BOARD_ID NUMBER,
	TITLE VARCHAR2(1000),
	CONTENT VARCHAR2(1000),
	MEMBER_ID NUMBER,
	CONSTRAINT PK_BOARD PRIMARY KEY(BOARD_ID),
	-- FK 설정
	CONSTRAINT FK_BOARD FOREIGN KEY(MEMBER_ID) 
		REFERENCES TBL_MEMBER(MEMBER_ID)
);

INSERT INTO TBL_MEMBER(MEMBER_ID, LOGIN_ID, PASSWORD)
VALUES(1, 'AAA', '1234');
INSERT INTO TBL_MEMBER(MEMBER_ID, LOGIN_ID, PASSWORD)
VALUES(2, 'BBB', '1234');


INSERT INTO TBL_BOARD(BOARD_ID, TITLE, CONTENT, MEMBER_ID)
VALUES(1, 'TEST TITLE1', 'CONTENT1', 1);

INSERT INTO TBL_BOARD(BOARD_ID, TITLE, CONTENT, MEMBER_ID)
VALUES(2, 'TEST TITLE2', 'CONTENT2', 1);

INSERT INTO TBL_BOARD(BOARD_ID, TITLE, CONTENT, MEMBER_ID)
VALUES(3, 'TEST TITLE3', 'CONTENT3', 2);

SELECT * FROM TBL_MEMBER tm ;
SELECT * FROM TBL_BOARD tb ;

-- 댓글
CREATE TABLE TBL_COMMENT(
	COMMENT_ID NUMBER,
	CONTENT VARCHAR2(1000),
	MEMBER_ID NUMBER,
	BOARD_ID NUMBER,
	CONSTRAINT PK_COMMENT PRIMARY KEY(COMMENT_ID),
	-- FK이름은 곂치면 안되기 때문에 FK_FK명_칼럼명 으로 설정한다 -> FK_COMMENT_MEMBER 
	CONSTRAINT FK_COMMENT_MEMBER FOREIGN KEY(MEMBER_ID) 
		REFERENCES TBL_MEMBER(MEMBER_ID),
	-- FK이름은 곂치면 안되기 때문에 FK_FK명_칼럼명 으로 설정한다 -> FK_COMMENT_BOARD
	CONSTRAINT FK_COMMENT_BOARD FOREIGN KEY(BOARD_ID)   
		REFERENCES TBL_BOARD(BOARD_ID)
);

-- 중요!! COMMENT의 ERD의 사용 -> SELECT , INSERT 사용법

DELETE FROM TBL_MEMBER tm ;

INSERT INTO TBL_MEMBER
(MEMBER_ID, LOGIN_ID, PASSWORD)
VALUES(0, '', '');

INSERT INTO TBL_BOARD
(BOARD_ID, TITLE, CONTENT, MEMBER_ID)
VALUES(0, '', '', 0);
--						PK		  ,  		 FK       , FK
INSERT INTO TBL_COMMENT(COMMENT_ID, CONTENT, MEMBER_ID, BOARD_ID)
VALUES(1, '배고파', 1, 1);
--						PK		  ,  		 FK       , FK
INSERT INTO TBL_COMMENT(COMMENT_ID, CONTENT, MEMBER_ID, BOARD_ID)
VALUES(2, 'JAVA코드', 1, 2);

INSERT INTO TBL_COMMENT(COMMENT_ID, CONTENT, MEMBER_ID, BOARD_ID)
VALUES(3, '저녁 추천', 2, 1);

-- 오류! 게시판 10번째가 없기 때문에
--INSERT INTO TBL_COMMENT(COMMENT_ID, CONTENT, MEMBER_ID, BOARD_ID)
----	  				회원,게시판
--VALUES(4, '점심 추천', 1, 10);


SELECT * FROM TBL_MEMBER tm ;
SELECT * FROM TBL_BOARD tb ;

SELECT * FROM TBL_COMMENT tc 
ORDER BY COMMENT_ID;

SELECT * FROM TBL_BOARD tb 
WHERE MEMBER_ID = 1;

SELECT * FROM TBL_COMMENT tc
WHERE BOARD_ID = 1;

-------------------------------------------------------------------------

--TBL_PHONE
--===============================================
--PHONE_ID		NUMBER		PK
--COLOR			VARCHAR2(1000)
--SIZE			NUMBER
--PRICE			NUMBER
--SALE			NUMBER
--PRODUCTION_DATE	DATE
--
--TBL_PHONE_CASE
--================================================
--CASE_ID			NUMBER		PK
--COLOR			VARCHAR2(1000)
--PRICE			NUMBER
--PHONE_ID		NUMBER		FK

CREATE TABLE TBL_PHONE(
	PHONE_ID NUMBER,
	COLOR VARCHAR2(1000),
	PHONE_SIZE NUMBER,
	PRICE NUMBER,
	SALE NUMBER,
	PRODUCTION_DATE DATE,
	CONSTRAINT PK_PHONE PRIMARY KEY(PHONE_ID)
);

CREATE TABLE TBL_PHONE_CASE(
	CASE_ID NUMBER,
	COLOR VARCHAR2(1000),
	PRICE NUMBER,
	PHONE_ID NUMBER,
	CONSTRAINT PK_CASE PRIMARY KEY(CASE_ID),
	CONSTRAINT FK_CASE FOREIGN KEY(PHONE_ID)
		REFERENCES TBL_PHONE(PHONE_ID)
);

INSERT INTO TBL_PHONE(PHONE_ID, COLOR, PHONE_SIZE, PRICE, SALE, PRODUCTION_DATE)
VALUES(1, '검은색', 12, 1000000, 20, '2024-05-27');

INSERT INTO TBL_PHONE_CASE(CASE_ID, COLOR, PRICE, PHONE_ID)
VALUES(1, '핑크색', 20000, 1);

SELECT * FROM TBL_PHONE tp ;
SELECT * FROM TBL_PHONE_CASE tpc ;



CREATE TABLE TBL_MEMBER(
	MEMBER_ID		NUMBER,
	MEMBER_NAME		VARCHAR2(1000),
	AGE				NUMBER ,
	PHONE_NUMBER	VARCHAR2(1000),
	ADDRESS			VARCHAR2(1000),
	CONSTRAINT PK_MEMBER PRIMARY KEY(MEMBER_ID)
);
CREATE TABLE TBL_BOOK(
	BOOK_ID			NUMBER,
	BOOK_NAME		VARCHAR2(1000),
	CATEGORY		VARCHAR2(1000) 
		CHECK (CATEGORY IN('인문학', '추리','IT','로맨스')),
	MEMBER_ID		NUMBER,
	CONSTRAINT PK_BOOK PRIMARY KEY(BOOK_ID),
	CONSTRAINT FK_MEMBER FOREIGN KEY(MEMBER_ID)
		REFERENCES TBL_MEMBER(MEMBER_ID)
);

INSERT INTO TBL_MEMBER (MEMBER_ID, MEMBER_NAME, AGE, PHONE_NUMBER, ADDRESS)
VALUES (1, '김송호', 26, '010-9205-7065', '강북구');
INSERT INTO TBL_MEMBER (MEMBER_ID, MEMBER_NAME, AGE, PHONE_NUMBER, ADDRESS) 
VALUES (2, '장희재', 33, '010-2380-2625', '노원구');

SELECT * FROM TBL_MEMBER tm ;


INSERT INTO TBL_BOOK(BOOK_ID, BOOK_NAME, CATEGORY) 
VALUES (1, '세종대왕', '인문학');
INSERT INTO TBL_BOOK (BOOK_ID, BOOK_NAME, CATEGORY) 
VALUES (2, '셜록홈즈', '추리');
INSERT INTO TBL_BOOK (BOOK_ID, BOOK_NAME, CATEGORY) 
VALUES (3, 'SQL 의 끝판왕!!', 'IT');
INSERT INTO TBL_BOOK (BOOK_ID, BOOK_NAME, CATEGORY) 
VALUES (4, '내가 좋아하는 그녀', '로맨스');


-- 회원 ID 1번 (김송호)가 책 ID 1번과 2번을 빌림
UPDATE TBL_BOOK SET MEMBER_ID = 1 WHERE BOOK_ID = 3;
UPDATE TBL_BOOK SET MEMBER_ID = 1 WHERE BOOK_ID = 4;
-- 회원 ID 2번 (장희재)가 책 ID 3번을 빌림
UPDATE TBL_BOOK SET MEMBER_ID = 2 WHERE BOOK_ID = 1;

SELECT
	MEMBER_ID "회원 번호",
	BOOK_ID "책 번호",
	BOOK_NAME "책 이름", 
	CATEGORY 카테고리
FROM
	TBL_BOOK
WHERE MEMBER_ID = 1;


SELECT
	MEMBER_ID "회원 번호",
	BOOK_ID "책 번호",
	BOOK_NAME "책 이름", 
	CATEGORY 카테고리
FROM
	TBL_BOOK
WHERE MEMBER_ID = 2;

--------------------------------------------------------------------------

-- 부모 테이블
SELECT * FROM TBL_PHONE tp; 
-- 자식 테이블
SELECT * FROM TBL_PHONE_CASE tpc; 

-- DATE타입의 칼럼에 문자타입의 값을 'YYYY-MM-DD' 의 형태로 넣으면
-- 자동으로 DATE타입으로 변환되어 들어간다.
INSERT INTO TBL_PHONE
(PHONE_ID, COLOR, PHONE_SIZE, PRICE, SALE, PRODUCTION_DATE)
VALUES(2, '핑크색', 10, 1200000, 0, '2024-05-28');

INSERT INTO TBL_PHONE
(PHONE_ID, COLOR, PHONE_SIZE, PRICE, SALE, PRODUCTION_DATE)
VALUES(3, '하얀색', 14, 800000, 10, SYSDATE - 10);

INSERT INTO TBL_PHONE
(PHONE_ID, COLOR, PHONE_SIZE, PRICE, SALE, PRODUCTION_DATE)
VALUES(4, '민트색', 10, 1100000, 0, '2020/10/10'); -- DATE -> YYYY/MM/DD 가능

INSERT INTO TBL_PHONE
(PHONE_ID, COLOR, PHONE_SIZE, PRICE, SALE, PRODUCTION_DATE)
VALUES(5, '보라색', 8, 1500000, 0 ,('2024년 11월 22일', 'YYYY"년" MM"월" DD"일"'));


INSERT INTO TBL_PHONE_CASE
(CASE_ID, COLOR, PRICE, PHONE_ID)
VALUES(1, '하얀색', 10000, 1);

INSERT INTO TBL_PHONE_CASE
(CASE_ID, COLOR, PRICE, PHONE_ID)
VALUES(2, '하늘색', 12000, 1);

INSERT INTO TBL_PHONE_CASE
(CASE_ID, COLOR, PRICE, PHONE_ID)
VALUES(3, '민트색', 5000, 2);

/*
 * 자식에서 부모테이블의 값을 참조중인 경우 부모테이블의 값을 수정할 수 없다
 * 이럴 경우 자식에서 참조중인 데이터를 다른 값으로 바꾸거나, NULL 로 변경하고 수정한다.
 */

-- 1. 참조중인 값을 NULL로 수정 후 진행
UPDATE TBL_PHONE_CASE 
SET PHONE_ID = NULL
WHERE CASE_ID = 3;

UPDATE TBL_PHONE 
SET PHONE_ID = 10
WHERE PHONE_ID = 2;

UPDATE TBL_PHONE_CASE 
SET PHONE_ID = 10
WHERE CASE_ID = 3;

-- 2. 참조중인 값을 다른 값으로 변경 후 수정
UPDATE TBL_PHONE_CASE 
SET PHONE_ID = 4
WHERE CASE_ID = 3;

UPDATE TBL_PHONE 
SET PHONE_ID = 2
WHERE PHONE_ID = 10;

UPDATE TBL_PHONE_CASE 
SET PHONE_ID = 2
WHERE CASE_ID = 3;

UPDATE TBL_PHONE_CASE 
SET PHONE_ID = 2
WHERE CASE_ID = 3;

SELECT * FROM TBL_PHONE tp ;
SELECT * FROM TBL_PHONE_CASE tpc ;

----------------------------------------------------------
-- 시퀀스(Sequnce)
-- 오라클에서 중복되지 않는 값을 자동으로 생성하는 객체
-- 보통 PK칼럼에 중복값을 방지하기 위해 사용한다.

-- 시퀀스 생성(CREATE SEQUENCE)
-- CREATE SEQUENCE 
CREATE SEQUENCE SEQ_MEMBER;
CREATE SEQUENCE SEQ_BOOK;

-- 여러 옵션이 있다
-- START WITH 시작숫자
-- INCREMENT BY 증감 숫자
-- 등등 여러 옵션이 있으나 일반적으로 별다른 옵션 없이 활용해도 된다.

-- 시퀀스 삭제(DROP SEQUENCE)
--DROP SEQUENCE SEQ_MEMBER;

-- 시퀀스 사용
-- 시퀀스명.NEXTVAL


-- SEQUENCE를 사용해 MEMBER_ID 를 하나씩 증가하면서 INSERT(삽입)한다
INSERT INTO TBL_MEMBER(MEMBER_ID, MEMBER_NAME, AGE, PHONE_NUMBER, ADDRESS)
VALUES(SEQ_MEMBER.NEXTVAL, '홍길동', 22, '010-1111-1111', '서울특별시');

INSERT INTO TBL_MEMBER(MEMBER_ID, MEMBER_NAME, AGE, PHONE_NUMBER, ADDRESS)
VALUES(SEQ_MEMBER.NEXTVAL, '김철수', 20, '010-2222-2222', '광주광역시');

INSERT INTO TBL_MEMBER(MEMBER_ID, MEMBER_NAME, AGE, PHONE_NUMBER, ADDRESS)
VALUES(SEQ_MEMBER.NEXTVAL, '신유리', 27, '010-3333-3333', '부산광역시');


INSERT INTO TBL_BOOK(BOOK_ID, BOOK_NAME, CATEGORY, MEMBER_ID)
VALUES(SEQ_BOOK.NEXTVAL, '셜록 홈즈', '추리', NULL);

INSERT INTO TBL_BOOK(BOOK_ID, BOOK_NAME, CATEGORY, MEMBER_ID)
VALUES(SEQ_BOOK.NEXTVAL, 'DBMS 의 끝판왕!', 'IT', 1);

INSERT INTO TBL_BOOK(BOOK_ID, BOOK_NAME, CATEGORY, MEMBER_ID)
VALUES(SEQ_BOOK.NEXTVAL, 'JAVA 의 모든것', 'IT', 1);


SELECT * FROM TBL_MEMBER;
SELECT * FROM TBL_BOOK;

-- NVL
SELECT BOOK_ID , BOOK_NAME , CATEGORY , NVL(MEMBER_ID, 0) 
FROM TBL_BOOK;

SELECT BOOK_ID , BOOK_NAME , CATEGORY , NVL(MEMBER_ID, '없음') 
FROM TBL_BOOK;

SELECT BOOK_ID , BOOK_NAME , CATEGORY , NVL2(MEMBER_ID, 1, 0) 
FROM TBL_BOOK;

SELECT BOOK_ID , BOOK_NAME , CATEGORY , NVL2(MEMBER_ID, '대여 중', '대여 가능') 
FROM TBL_BOOK;

---------------------------------------------------------------------------------------------
SELECT * FROM PLAYER p ;

SELECT * FROM PLAYER p 
WHERE TEAM_ID = 'K01';

SELECT * FROM TEAM t 
ORDER BY TEAM_ID ;

-- [실습]
-- PLAYER 테이블에서 WEIGHT가 70 이상이고 80이하인 선수 조회
SELECT  PLAYER_NAME ,WEIGHT 
FROM PLAYER p 
WHERE WEIGHT >= 70 AND WEIGHT < 80
ORDER BY WEIGHT ;

SELECT  PLAYER_NAME ,WEIGHT 
FROM PLAYER p 
WHERE WEIGHT BETWEEN  70 AND 80
ORDER BY WEIGHT ;


-- PLAYER 테이블에서 TEAM_ID가 'K03'이고 HEIGHT가 180 미만인 선수 조회
SELECT PLAYER_NAME , TEAM_ID , HEIGHT 
FROM PLAYER p 
WHERE TEAM_ID = 'K03' AND HEIGHT < 180
ORDER BY HEIGHT ;

-- PLAYER 테이블에서 TEAM_ID가 'K06'이고 NICKNAME이 '제리'인 선수 조회
SELECT PLAYER_NAME , TEAM_ID , NICKNAME  
FROM PLAYER p 
WHERE TEAM_ID = 'K06' AND NICKNAME = '제리'

-- PLAYER 테이블에서 HEIGHT가 170 이상이고 WEIGHT가 80이상인 선수 이름 조회
SELECT PLAYER_NAME , HEIGHT , WEIGHT 
FROM PLAYER p 
WHERE HEIGHT >= 170 AND WEIGHT >= 80
ORDER BY HEIGHT; 

-- STADIUM 테이블에서 SEAT_COUNT가 30000초과이고 41000이하인 경기장 조회
SELECT STADIUM_NAME , SEAT_COUNT 
FROM STADIUM s 
WHERE SEAT_COUNT > 30000 AND SEAT_COUNT <= 41000
ORDER BY SEAT_COUNT 

-- PLAYER테이블에서 TEAM_ID가 'K02'이거나 'K07'이고 포지션은 'MF'인 선수 조회

SELECT PLAYER_NAME , TEAM_ID , "POSITION" 
FROM PLAYER p 
WHERE TEAM_ID = 'K02' OR TEAM_ID = 'K07' AND "POSITION" = 'MF';

-- SQL에서 OR보다 AND가 우선순위가 높다.
-- POSITION은 예약어 이므로 그냥 쓰면 안되고 ""로 묶어서 사용한다.
SELECT * FROM PLAYER p 
WHERE "POSITION" = 'MF' AND (TEAM_ID = 'K07' OR TEAM_ID = 'K02') -- 우선 순위
ORDER BY TEAM_ID ;

SELECT PLAYER_NAME , TEAM_ID , "POSITION" 
FROM PLAYER p 
WHERE TEAM_ID IN ('K02' , 'K07') AND "POSITION" = 'MF';

--------------------------------------------------------------------------------------

-- TCL : 트랜잭션 제어어

-- 트랜잭션 
-- 하나의 작업 단위
-- 여러 SQL문의 묶음

-- COMMIT
-- 트랜잭션에 담긴 모든 작업을 확정(저장)하는 명령어

-- ROLLBACK
-- 트랜잭션에 담긴 모든 작업을 취소하고 이전 커밋 시점으로 되돌리는 명령어
--  

SELECT * FROM EMP;
DELETE FROM EMP;

ROLLBACK;


CREATE TABLE TBL_MEMBER(
	MEMBER_ID NUMBER,
	NAME VARCHAR2(1000)
);

INSERT INTO TBL_MEMBER(MEMBER_ID, NAME)
VALUES(1, '김철수');

INSERT INTO TBL_MEMBER(MEMBER_ID, NAME)
VALUES(2, '홍길동');

-- TRUNCATE와 DELETE의 차이
-- TRUNCATE : DDL (롤백 불가능)
-- DELETE : DML (롤백 가능)

-- 트랜잭션은 DML만 담아서 관리해준다!!
DELETE FROM TBL_MEMBER; -- DML
TRUNCATE TABLE TBL_MEMBER; -- DDL

COMMIT;
ROLLBACK;
SELECT * FROM TBL_MEMBER;


UPDATE PLAYER 
SET PLAYER_NAME = 'A'
WHERE TEAM_ID = 'K01';

SELECT * FROM PLAYER p 
ORDER BY TEAM_ID ;

ROLLBACK;

------------------------------------------------------------------------------

/*
 * 집계 함수 : 결과 행 1개
 * 주의 사항 : NULL은 집계에서 제외된다. WHERE절 에서는 사용 불가
 * 
 * 평균 : AVG()
 * 최대값 : MAX()
 * 최소값 : MIN()
 * 총 합 : SUM()
 * 개수 : COUNT()
 */

SELECT AVG(HEIGHT) FROM PLAYER p ;
SELECT MAX(HEIGHT) FROM PLAYER p ;
SELECT MIN(HEIGHT) FROM PLAYER p ;
SELECT SUM(HEIGHT) FROM PLAYER p ;
SELECT COUNT(HEIGHT) FROM PLAYER p ;

-- NULL을 포함 시켜서 COUNT하기
SELECT COUNT(HEIGHT) FROM PLAYER p ;
SELECT NVL(HEIGHT,0) FROM PLAYER p ;
SELECT COUNT(NVL(HEIGHT,0)) FROM PLAYER p ;

-- GROUP BY, HAVING 절
-- GROUP BY 절은 특정 컬럼에 있는 값을 그룹으로 묶어서 데이터를 집계할때 사용한다.
-- ORDER BY 와 동일하게 SELECT문에서 사용하며 위치는 WHERE절 다음, ORDER BY 절 이전에 작성
-- HAVING 절은 GROUP BY 다음에 사용하며, SELECT의 WHERE처럼 조건을 거는 용도로 사용한다
-- WHERE 절은 쿼리 전체에 조건을 걸기위한 용도이며, 그 데이터를 GROUP BY로 묶어줄 때
-- 											묶는 조건이 필요하다면 HAVING을 사용한다

-- WHERE절은 집계 함수가 불가능하지만 HAVING은 가능하다.

-- GROUP BY : ~ 별 (예 : 포지션 별 평균키)
-- GROUP BY 칼럼명 HAVING 조건식


-- PLAYER 테이블에서 포지션 종류 조회
SELECT DISTINCT "POSITION"  
FROM PLAYER p 

/*
 * 오류 발생!!
 * GROUP BY 로 포지션 종류를 보게 되면
 * 4개의 포지션이 나오게 되는데 SELECT로 모든 정보를 본다는 것은
 * 말이 되지 않는다. 4개의 행으로 모든 정보를 나타낼 수 없기 때문이다.
 */
SELECT * FROM PLAYER p 
GROUP BY "POSITION" ;

/*
 * 포지션으로 그룹화를 해준다면 그룹화 대상인 포지션 칼럼을 조회할 수 있다.
 * 반드시 조회를 해야하는 것은 아니지만 무엇을 기준으로 그룹을 지었는지 알기 쉬우므로
 * 같이 조회하는게 편리하다.
 */
SELECT "POSITION" FROM PLAYER p 
GROUP BY "POSITION" ;

/*
 * 포지션 별 평균키를 구하기 위해서는 각 그룹을 하나의 행 데이터로 표현할 수 있어야한다.
 * 집계함수는 몇 개의 데이터가 들어가도 결과를 한 행으로 뽑아주므로 GROUP BY와 궁합이 좋다.
 */
SELECT "POSITION" , AVG(HEIGHT) FROM PLAYER p 
GROUP BY "POSITION" ;


SELECT * FROM PLAYER p 
WHERE "POSITION" = 'MF';

-- PLAYER 테이블에서 몸무게가 80이상인 선수들의 평균 키가 180 초과인 포지션 조회
SELECT "POSITION" 포지션, AVG(HEIGHT) "평균 키"
FROM PLAYER p 
WHERE WEIGHT >= 80
GROUP BY "POSITION" HAVING AVG(HEIGHT) > 180
ORDER BY "평균 키";

-- WHERE 절에 조건을 사용했을 때와 HAVING절에 조건을 사용했을때
-- 동일한 결과가 나온다면 WHERE절을 사용하는게 효과적이다
SELECT "POSITION" , AVG(HEIGHT) FROM PLAYER p 
WHERE "POSITION" = 'MF'
GROUP BY "POSITION" ;

SELECT "POSITION" , AVG(HEIGHT) FROM PLAYER p 
GROUP BY "POSITION" HAVING "POSITION" = 'MF';

/*
 * EMPLOYEES 테이블에서 JOB_ID별 평균 SALAFY가 10000미만인
 * JOB_ID 조회
 * JOB_ID는 알파벳 순으로 정렬
 */

SELECT JOB_ID , AVG(SALARY) "평균 월급"
FROM EMPLOYEES e 
GROUP BY JOB_ID HAVING AVG(SALARY) < 10000
ORDER BY "평균 월급" ;

-- ★SQL 실행순서★
-- FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY

--------------------------------------------------------------------------------


/*
 * PLAYER 테이블
 */

/* 
 * PLAYER_ID가 2007로 시작하는 선수들 중 
 * POSITION별 평균 키를 조회 -> SELECT
 */
SELECT "POSITION", AVG(HEIGHT)
FROM PLAYER p 
WHERE PLAYER_ID LIKE '2007%' 
GROUP BY "POSITION";


/*
 * 선수들 중 포지션이 DF 선수들의 평균 키를 TEAM_ID 별로 조회하고 -> SELECT
 * 평균 키 오름차순으로 정렬하기 -> ORDER BY
 */

SELECT
	TEAM_ID ,
	AVG(HEIGHT) "평균 키"
FROM
	PLAYER p
WHERE
	p."POSITION" = 'DF'
GROUP BY
	p.TEAM_ID
ORDER BY
	"평균 키" ;


/*
 * 포지션이 MF인 선수들의 -> WHERE "POSITION" = 'MF'
 * 입단연도 별 평균 몸무게, 평균 키를 구한다. -> GROUP BY JOIN_YYYY
 * 칼럼명은 입단연도, 평균 몸무게, 평균 키 로 표시한다. -> SELECT 별칭
 * 입단연도를 오름차순으로 정렬한다. -> ORDER BY
 */
SELECT
	JOIN_YYYY 입단연도 ,
	ROUND(AVG(WEIGHT), 2) "평균 몸무게",
	ROUND(AVG(HEIGHT) , 2) "평균 키"
FROM
	PLAYER p
WHERE
	"POSITION" = 'MF'
	AND JOIN_YYYY IS NOT NULL
GROUP BY
	JOIN_YYYY
ORDER BY
	JOIN_YYYY;

-- 소수점 빼기
SELECT ROUND(10/3 , 2) FROM DUAL;

/*
 * EMPLOYEES 테이블
 */

/*
 * 핸드폰번호가 515로 시작하는 사원들의 -> WHERE POHNE_NUMBER = 515
 * JOB_ID별 SALARY 평균을 구한다. -> GROUP BY JOB_ID HAVING AVG(SALARY)
 * 조회 컬럼은 담당 업무, 평균 급여 로 표시한다. -> SELECT 별칭
 * 평균 급여가 높은 순으로 정렬한다. -> ORDER BY AVG(SALARY)또는 "평균 급여"
 */

SELECT JOB_ID "담당 업무", AVG(SALARY) "평균 급여"
FROM EMPLOYEES e 
WHERE PHONE_NUMBER LIKE '515%'
GROUP BY JOB_ID
ORDER BY "평균 급여" DESC;

/*
 * COMMISSION_PCT 별 평균 급여를 조회한다. -> SELECT AVG(SALARY)
 * COMMISSION_PCT 를 오름차순으로 정렬하며  -> ORDER BY COMMISSION_PCT
 * HAVING절을 사용하여 NULL은 제외한다. -> GROUP BY COMMISSION_PCT HAVING IS NOT NULL
 */

-- HAVING 의 조건은 그룹화하는 칼럼 또는 집게함수를 사용한다
SELECT COMMISSION_PCT , ROUND(AVG(SALARY)) "평균 급여"
FROM EMPLOYEES e 
GROUP BY COMMISSION_PCT  
HAVING COMMISSION_PCT IS NOT NULL
ORDER BY COMMISSION_PCT;


