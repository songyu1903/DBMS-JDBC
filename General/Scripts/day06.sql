-- EMPLOYEES 테이블에서 EMAIL, 성, 이름 조회하고 직무이름을 같이 조회하기
SELECT * FROM EMPLOYEES e ;
SELECT * FROM JOBS j 

SELECT *
FROM EMPLOYEES e JOIN JOBS j 
ON E.JOB_ID = J.JOB_ID ;

SELECT EMAIL 이메일 , FIRST_NAME || ' ' || LAST_NAME 풀네임 , J.JOB_TITLE 직무이름  
FROM JOBS j JOIN EMPLOYEES e 
ON j.JOB_ID = e.JOB_ID  

-- EMPLOYEES 테이블에서 HIREDATE가 1998~2000년 까지인 사원의 정보와 부서명을 같이 조회
SELECT * FROM EMPLOYEES e ; 
SELECT * FROM DEPARTMENTS d ;

SELECT * FROM EMPLOYEES e 
WHERE HIRE_DATE BETWEEN '1998-01-01' AND '2000-12-31'

SELECT E.* , D.DEPARTMENT_NAME 
FROM EMPLOYEES e JOIN DEPARTMENTS d 
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.HIRE_DATE BETWEEN '1998-01-01' AND '2000-12-31';

SELECT TO_CHAR(HIRE_DATE , 'YYYY') FROM EMPLOYEES e; 

SELECT * FROM EMPLOYEES e 
WHERE TO_CHAR(HIRE_DATE , 'YYYY') BETWEEN '1998' AND '2000';

SELECT SYSDATE FROM DUAL;

SELECT TO_CHAR(SYSDATE, 'YYYY/MM/DD') FROM DUAL; 

SELECT TO_DATE ('2020-01-01', 'YYYY-MM-DD')
FROM DUAL;


-- EMP 테이블에서 ENAME에 L이 포함된 사원들의 이름, DNAME, LOC 조회
SELECT * FROM  EMP e ;
SELECT * FROM  DEPT d ;


SELECT E.ENAME , D.DNAME , D.LOC 
FROM EMP e JOIN DEPT d 
ON E.DEPTNO = D.DEPTNO
WHERE E.ENAME LIKE '%L%';

----------------------------------------------------------------------------

-- 3개의 테이블을 JOIN
SELECT * FROM DEPARTMENTS d ; -- LOCAITION_ID 를 FK 로 사용중
SELECT * FROM LOCATIONS l ;  -- COUNTRY_ID 를 FK로 사용중
SELECT * FROM COUNTRIES c ;

SELECT D.DEPARTMENT_ID , D.DEPARTMENT_NAME,
	L.STREET_ADDRESS , L.CITY , L.POSTAL_CODE ,
	C.COUNTRY_NAME 
FROM DEPARTMENTS d JOIN LOCATIONS l 
ON D.LOCATION_ID = L.LOCATION_ID 
JOIN COUNTRIES c 
	ON L.COUNTRY_ID = C.COUNTRY_ID;

------------------------------------------------------------------------

-- 축구 선수들 중에서 각 팀별로 키가 가장 큰 선수들의 전체 정보를 조회
SELECT TEAM_ID , MAX(HEIGHT) HEIGHT  
FROM PLAYER p 
GROUP BY TEAM_ID ;
 
SELECT * FROM PLAYER p ;

SELECT *
FROM PLAYER p JOIN (
	SELECT TEAM_ID , MAX(HEIGHT) HEIGHT 
	FROM PLAYER p 
	GROUP BY TEAM_ID
) S1
ON P.TEAM_ID = S1.TEAM_ID AND P.HEIGHT = S1.HEIGHT;

-- 위의 문제를 JOIN 없이 풀어보기
-- (A, B) IN (C, D) : A = C AND B = D
SELECT TEAM_ID , MAX(HEIGHT)
FROM PLAYER p  
GROUP BY TEAM_ID ;

SELECT * FROM PLAYER p 
WHERE (TEAM_ID, p.HEIGHT) IN (
	SELECT TEAM_ID , MAX(HEIGHT)
	FROM PLAYER p  
	GROUP BY TEAM_ID
);

-- EMP 테이블의 SAL를 참고하여, SALGRADE 테이블의 해당되는 등급을 조회한다.
-- 죄회 결과는 모든 사원의 정보와 GRADE를 같이 포함한다.
SELECT * FROM EMP e; 
SELECT * FROM SALGRADE s; -- PK FK 가 없다

-- 연관관계가 없는 테이블간의 JOIN
-- 비등가 JOIN을 활용
SELECT E.*, S.GRADE 
FROM EMP e JOIN SALGRADE s 
ON E.SAL BETWEEN S.LOSAL AND S.HISAL; -- BETWEEN ->  >=  =< 

-- EMP 테이블에서 각 사원의 매니저 이름 조회
-- 조회 결과 : 사원번호, 사원이름, 매니저 번호, 매니저 이름
SELECT * FROM EMP e ;

-- EMP 테이블에서 MGR칼럼이 매니저 번호이다.
-- MGR은 EMP번호와 일치한다.
-- 즉, 사원 정보와 매니저 정보가 모두 EMP테이블에 존재한다.
-- 이 경우 자기자신을 JOIN하여 데이터를 조회한다.(SELF JOIN)

SELECT
	E.EMPNO 사원번호,
	E.ENAME 사원이름,
	M.EMPNO 매니저번호,
	M.ENAME 매니저이름
FROM
	EMP E
JOIN EMP M 
ON
	E.MGR = M.EMPNO ;



-- 외부 JOIN
CREATE TABLE TBL_GRADE(
	GRADE_ID NUMBER,
	NAME VARCHAR2(1000),
	CONSTRAINT PK_GRADE PRIMARY KEY(GRADE_ID)
);

CREATE TABLE TBL_USER(
	USER_ID NUMBER,
	LOGIN_ID VARCHAR2(1000),
	GRADE_ID NUMBER,
	CONSTRAINT PK_USER PRIMARY KEY(USER_ID),
	CONSTRAINT FK_USER FOREIGN KEY(GRADE_ID) 
		REFERENCES TBL_GRADE(GRADE_ID)
);

CREATE SEQUENCE SEQ_GRADED;
CREATE SEQUENCE SEQ_USER;

INSERT INTO TBL_GRADE(GRADE_ID, NAME)
VALUES(SEQ_GRADED.NEXTVAL, 'VVIP');

INSERT INTO TBL_GRADE(GRADE_ID, NAME)
VALUES(SEQ_GRADED.NEXTVAL, 'VIP');

INSERT INTO TBL_GRADE(GRADE_ID, NAME)
VALUES(SEQ_GRADED.NEXTVAL, 'NORMAL');


SELECT * FROM TBL_GRADE tg ;

INSERT INTO TBL_USER(USER_ID, LOGIN_ID, GRADE_ID)
VALUES(SEQ_USER.NEXTVAL, 'A', 1);

INSERT INTO TBL_USER(USER_ID, LOGIN_ID, GRADE_ID)
VALUES(SEQ_USER.NEXTVAL, 'B', 2);

SELECT * FROM TBL_USER tu ;

SELECT * FROM TBL_GRADE G JOIN TBL_USER U
ON G.GRADE_ID = U.GRADE_ID ;

-- OUTER JOIN은 OUTER를 생략 가능하다.
SELECT * 
FROM TBL_GRADE G LEFT JOIN TBL_USER U
ON G.GRADE_ID = U.GRADE_ID ;

-------------------------------------------------------

SELECT * FROM TBL_MEMBER tm ;

CREATE TABLE TBL_MEMBER(
	MEMBER_ID NUMBER,
	LOGIN_ID VARCHAR2(1000),
	CONSTRAINT PK_MEMBER PRIMARY KEY(MEMBER_ID)
);

CREATE SEQUENCE SEQ_MEMBER;

CREATE TABLE TBL_BOARD(
	BOARD_ID NUMBER,
	TITLE VARCHAR2(1000),
	CONTENT VARCHAR2(1000),
	MEMBER_ID NUMBER,
	CONSTRAINT PK_BOARD PRIMARY KEY(BOARD_ID),
	CONSTRAINT FK_BOARD FOREIGN KEY(MEMBER_ID)
		REFERENCES TBL_MEMBER(MEMBER_ID) 
);

CREATE SEQUENCE SEQ_BOARD;

INSERT INTO TBL_MEMBER(MEMBER_ID, LOGIN_ID)
VALUES(SEQ_MEMBER.NEXTVAL, 'aaa');
INSERT INTO TBL_MEMBER(MEMBER_ID, LOGIN_ID)
VALUES(SEQ_MEMBER.NEXTVAL, 'bbb');
INSERT INTO TBL_MEMBER(MEMBER_ID, LOGIN_ID)
VALUES(SEQ_MEMBER.NEXTVAL, 'ccc');

SELECT * FROM TBL_MEMBER tm ;

INSERT INTO TBL_BOARD(BOARD_ID, TITLE, CONTENT, MEMBER_ID)
VALUES(SEQ_BOARD.NEXTVAL, 'TEST TITLE01', 'TEST CONTENT01', 1);
INSERT INTO TBL_BOARD(BOARD_ID, TITLE, CONTENT, MEMBER_ID)
VALUES(SEQ_BOARD.NEXTVAL, 'TEST TITLE02', 'TEST CONTENT02', 1);
INSERT INTO TBL_BOARD(BOARD_ID, TITLE, CONTENT, MEMBER_ID)
VALUES(SEQ_BOARD.NEXTVAL, 'TEST TITLE03', 'TEST CONTENT03', 2);


-- 회원가입은 그냥 INSERT 쿼리를 사용하면 된다.

-- 게시물 리스트 페이지
-- 게시물 번호, 타이틀, 작성자 로그인 아이디 같이 조회한다.
-- 전체 BOARD에 대한 데이터를 뿌려줘야한다.

SELECT * FROM TBL_BOARD tb ;
SELECT * FROM TBL_MEMBER tm ;

-- 게시물 리스트 페이지
SELECT BOARD_ID "게시물 번호", TITLE 타이틀, TM.LOGIN_ID  "로그인 아이디"
FROM TBL_BOARD tb JOIN TBL_MEMBER tm 
ON TM.MEMBER_ID = TB.MEMBER_ID 
ORDER BY "게시물 번호";

-- 게시물 상세보기 페이지
-- 필요한 데이터 : 게시물 제목, 내용, 작성자 로그인 아이디
-- 특정 게시물에 대해 조회 : 1번 게시물만 조회

SELECT TITLE "게시물 제목", CONTENT "내용", TM.LOGIN_ID "로그인 아이디"
FROM TBL_BOARD tb JOIN TBL_MEMBER tm 
ON TM.MEMBER_ID = TB.MEMBER_ID
WHERE TB.TITLE = 'TEST TITLE01'

-- 조금 더 신경쓴 쿼리
SELECT TITLE "게시물 제목", CONTENT "내용", TM.LOGIN_ID "로그인 아이디"
FROM TBL_BOARD tb JOIN TBL_MEMBER tm 
ON TM.MEMBER_ID = TB.MEMBER_ID AND TB.BOARD_ID = 1

----------------------------------------------------------------------------------

-- M, B 테이블에서 N : N 상속은
-- L 테이블 이라는 중간테이블을 만들어 M, B 테이블의 FK 를 걸고 상속한다

-- 좋아요 테이블
CREATE TABLE TBL_LIKE(
	MEMBER_ID NUMBER,
	BOARD_ID NUMBER,
	-- PK를 MEMBER_ID 와 BOARD_ID 를 복합키로 사용
	CONSTRAINT PK_LIKE PRIMARY KEY(MEMBER_ID, BOARD_ID),
	CONSTRAINT FK_LIKE_MEMBER FOREIGN KEY(MEMBER_ID) REFERENCES TBL_MEMBER(MEMBER_ID),
	CONSTRAINT FK_LIKE_BOARD FOREIGN KEY(BOARD_ID) REFERENCES TBL_BOARD(BOARD_ID)
);


INSERT INTO TBL_LIKE(MEMBER_ID, BOARD_ID)
VALUES(1, 1);
INSERT INTO TBL_LIKE(MEMBER_ID, BOARD_ID)
VALUES(1, 2);
INSERT INTO TBL_LIKE(MEMBER_ID, BOARD_ID)
VALUES(1, 3);

INSERT INTO TBL_LIKE(MEMBER_ID, BOARD_ID)
VALUES(2, 1);
INSERT INTO TBL_LIKE(MEMBER_ID, BOARD_ID)
VALUES(2, 2);
INSERT INTO TBL_LIKE(MEMBER_ID, BOARD_ID)
VALUES(3, 1);

SELECT * FROM TBL_LIKE tl;

-- 1번 회원이 내정보 페이지에 들어갔다. -> WHERE
-- 내정보 페이지에는 내가 좋아요를 누른 게시물 목록이 나타난다. -> TBL_LIKE , TBL_BOARD
-- 게시물 목록에 필요한 정보는 게시물의 제목과, 게시물의 작성자이다. -> TBL_MEMBER
-- 필요한 정보를 조회하는 쿼리를 만들기!

SELECT * FROM TBL_BOARD tb ;
SELECT * FROM TBL_LIKE tl ;

-- 3 JOIN
SELECT TB.TITLE, TB.BOARD_ID, TB.MEMBER_ID , TM.LOGIN_ID 
FROM TBL_BOARD tb JOIN TBL_LIKE tl  
ON TB.BOARD_ID = TL.BOARD_ID  AND TL.MEMBER_ID = 1
	JOIN TBL_MEMBER tm
ON TM.MEMBER_ID = TB.MEMBER_ID;

/*
 * 게시물 리스트를 조회한다.
 * 필요한 정보 : 게시물 번호, 작성자 로그인 아이디, 해당 게시물의 좋아요 수 -> TBL_BOARD, TBL_MEMBER, TBL_LIKE
 * 
 * 리스트 이기 때문에 모든 게시물 정보가 나타나야한다.
 */

SELECT *
FROM TBL_BOARD B JOIN TBL_MEMBER M
ON B.MEMBER_ID = M.MEMBER_ID 

SELECT B.BOARD_ID , B.TITLE , M.LOGIN_ID 
FROM TBL_BOARD B JOIN TBL_MEMBER M
ON B.MEMBER_ID = M.MEMBER_ID 

SELECT COUNT(MEMBER_ID) "좋아요 누른 멤버 수"
FROM TBL_LIKE L
WHERE BOARD_ID = 1;

SELECT B.BOARD_ID , B.TITLE , M.LOGIN_ID , 
	(SELECT COUNT(MEMBER_ID)
	FROM TBL_LIKE L
	WHERE L.BOARD_ID = B.BOARD_ID 
	)"좋아요 누른 회원 수"
FROM TBL_BOARD B JOIN TBL_MEMBER M
ON B.MEMBER_ID = M.MEMBER_ID 

----------------------------------------------------------------
-- 팔로우 기능


CREATE TABLE TBL_FOLLOW(
	FOLLOW_FROM NUMBER,
	FOLLOW_TO NUMBER,
	CONSTRAINT PK_FOLLOW PRIMARY KEY(FOLLOW_FROM, FOLLOW_TO),
	CONSTRAINT FK_FOLLOW_FROM FOREIGN KEY(FOLLOW_FROM) REFERENCES TBL_MEMBER(MEMBER_ID),
	CONSTRAINT FK_FOLLOW_TO FOREIGN KEY(FOLLOW_TO) REFERENCES TBL_MEMBER(MEMBER_ID)
);

-- 팔로잉 : 내가 다른 사람한테 팔로우
-- 팔로워 : 다른 사람이 나한테 팔로우
INSERT INTO TBL_FOLLOW(FOLLOW_FROM, FOLLOW_TO)
VALUES(1, 2);
INSERT INTO TBL_FOLLOW(FOLLOW_FROM, FOLLOW_TO)
VALUES(1, 3);

INSERT INTO TBL_FOLLOW(FOLLOW_FROM, FOLLOW_TO)
VALUES(2, 1);

INSERT INTO TBL_FOLLOW(FOLLOW_FROM, FOLLOW_TO)
VALUES(3, 2);

SELECT * FROM TBL_FOLLOW;

-- 1번 회원이 내정보 페이지에 진입했다.
-- 내정보 페이지에는 내가 팔로우한 회원들의 목록이 나타난다. -> FOLLOW_FROM
-- 목록에는 회원의 번호, 로그인 아이디가 나타난다.

SELECT * FROM TBL_MEMBER;
SELECT * FROM TBL_FOLLOW;

SELECT M.MEMBER_ID 회원번호, M.LOGIN_ID "로그인 아이디", F.FOLLOW_TO 팔로잉
FROM TBL_FOLLOW F JOIN TBL_MEMBER M
ON F.FOLLOW_TO = M.MEMBER_ID 
WHERE FOLLOW_FROM = 1;

/*
 * 내정보 페이지에 진입하면 내 로그인 아이디와
 * 팔로잉 수, 팔로워 수 가 조회된다. -> COUNT 2개
 * 1번 회원이 내정보 페이지에 진입했을 때 필요한 쿼리를 만들기!
 */

SELECT COUNT(FOLLOW_FROM)
FROM TBL_FOLLOW tf 

SELECT COUNT(FOLLOW_TO)
FROM TBL_FOLLOW tf 


-- 서브 쿼리 2개를 사용해 팔로잉이랑 팔로워수 체크
SELECT M.LOGIN_ID,
	(SELECT COUNT(FOLLOW_TO)
	 FROM TBL_FOLLOW F
	 WHERE F.FOLLOW_FROM = M.MEMBER_ID 
	) "팔로잉 수"
	,
	(SELECT COUNT(FOLLOW_FROM)
	 FROM TBL_FOLLOW F
	 WHERE F.FOLLOW_TO = M.MEMBER_ID 
	) "팔로워 수"
FROM TBL_MEMBER M
WHERE M.MEMBER_ID = 1;

-------------------------------------------------------------------------










